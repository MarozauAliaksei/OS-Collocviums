    Процедурная декомпозиция:
    Процедурная декомпозиция представляет собой подход к разработке программ, основанный на разделении задачи на более мелкие процедуры или функции. Это позволяет разбивать сложные задачи на более простые подзадачи, что упрощает понимание, сопровождение и модификацию кода. Процедурная декомпозиция включает в себя создание набора процедур (или функций), которые выполняют конкретные задачи, и вызов этих процедур для выполнения общей задачи.

    Динамический полиморфизм:
    Динамический полиморфизм - это концепция объектно-ориентированного программирования (ООП), которая позволяет объектам одного типа использовать методы или операции, определенные для объектов другого типа. Это достигается через использование наследования и виртуальных функций. В языках программирования, поддерживающих динамический полиморфизм, объекты могут вызывать методы базового класса, а конкретная реализация метода будет определена на этапе выполнения в зависимости от фактического типа объекта.

    Инкапсуляция:
    Инкапсуляция - это принцип объектно-ориентированного программирования, который предполагает упаковку данных (переменных) и методов (функций), работающих с этими данными, в единый объект. Таким образом, данные и методы, работающие с ними, объединяются внутри класса. Инкапсуляция обеспечивает контроль доступа к данным, скрывая детали реализации от внешнего мира и предоставляя интерфейс для взаимодействия с объектом. В ООП инкапсуляция также позволяет контролировать изменение состояния объекта только через методы класса, что способствует поддержанию целостности данных.
Фабричный метод (Factory Method):
Описание через призму инкапсуляции:
Фабричный метод - это порождающий паттерн проектирования, который предоставляет интерфейс для создания объекта в суперклассе, но позволяет подклассам изменять тип создаваемых объектов. Он инкапсулирует процесс создания объектов, делегируя это создание подклассам. Таким образом, клиентский код, который использует фабричный метод, работает с абстрактными типами данных, не зная конкретных классов, которые будут созданы.

Пример использования:
Предположим, у нас есть иерархия классов для различных типов транспортных средств (автомобиль, велосипед, самолет). Мы можем создать фабричный метод createTransport(), который будет определен в суперклассе TransportFactory. Каждый подкласс (CarFactory, BicycleFactory, AirplaneFactory) реализует этот метод, возвращая соответствующий объект своего типа.

python

# Абстрактная фабрика транспортных средств
class TransportFactory:
    def createTransport(self):
        pass

# Конкретные фабрики
class CarFactory(TransportFactory):
    def createTransport(self):
        return Car()

class BicycleFactory(TransportFactory):
    def createTransport(self):
        return Bicycle()

class AirplaneFactory(TransportFactory):
    def createTransport(self):
        return Airplane()

# Использование фабричного метода
car_factory = CarFactory()
car = car_factory.createTransport()

Composite:
Описание через призму инкапсуляции:
Composite - это структурный паттерн проектирования, который позволяет клиентам обрабатывать отдельные объекты и их композиции одинаковым образом. Он инкапсулирует детали структуры объектов внутри единого интерфейса, что позволяет клиентам манипулировать как отдельными объектами, так и их составными структурами.

Пример использования:
Рассмотрим структуру графических элементов, таких как прямоугольники и круги, которые могут быть объединены в группы. Используя Composite, мы можем инкапсулировать детали манипуляции с элементами в общем интерфейсе, независимо от того, является ли элемент примитивом или группой.

python

# Абстрактный класс компонента
class Graphic:
    def draw(self):
        pass

# Примитивный элемент
class Rectangle(Graphic):
    def draw(self):
        print("Drawing a rectangle")

# Примитивный элемент
class Circle(Graphic):
    def draw(self):
        print("Drawing a circle")

# Компоновщик (группа)
class Group(Graphic):
    def __init__(self):
        self.graphics = []

    def add(self, graphic):
        self.graphics.append(graphic)

    def draw(self):
        print("Drawing a group:")
        for graphic in self.graphics:
            graphic.draw()

# Использование Composite
rectangle = Rectangle()
circle = Circle()

group = Group()
group.add(rectangle)
group.add(circle)

group.draw()

В данном примере, независимо от того, является ли элемент простым прямоугольником, кругом или группой этих элементов, клиентский код может использовать единый метод draw для отображения графического содержимого.